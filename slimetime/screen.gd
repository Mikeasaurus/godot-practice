extends Node2D

var score: int = 0
var bugs_eaten: int = 0
var total_bugs: int = 0
@onready var start_time: int = Time.get_ticks_msec()

var is_game_over: bool = false
var is_dead_multiplayer: bool = false
var is_in_menu: bool = false

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	# Connect the menu toggle key for pausing / unpausing the game.
	MenuHandler.pause.connect(pause_game)
	MenuHandler.done_submenus.connect(unpause_game)
	if Globals.touchscreen_controls:
		$Overlay/Shortcuts/PauseButton.show()
		$Overlay/Shortcuts/PauseButton.pressed.connect(pause_game)
	if Globals.is_client:
		$Overlay/Shortcuts/ChatButton.show()
		$Overlay/Shortcuts/BeachballButton.show()
		$Overlay/Shortcuts/ReactionButton.show()
	# Use better names for the sprites generated from SpriteTileMapLayer.
	# The default names are autogenerated, and are causing problems with MultiplayerSyncrhonizer.
	# In particular, sometimes the auto-generated names don't match up to the right sprite between client and server?
	# First, need to force the TileMapLayer to instantiate its scenes, because normally this is deferred and we can't
	# see the sprites from this _ready() function.
	$SpriteTileMapLayer.update_internals()
	for c in $SpriteTileMapLayer.get_children():
		c.name = c.scene_file_path.split('/')[-1].split('.')[0]+"_"+str(c.position.x)+"_"+str(c.position.y)
		# Define visibility range for bugs' MultiplayerSynchronizer.
		# Will stop sending sync updates once out of range.
		# Need to define it within an anonymous function here so we have access to
		# the bug context.
		if Globals.is_server:
			var f = func bug_is_visible (peer: int) -> bool:
				if peer == 0: return false
				var w: Worm = peer_worm(peer)
				# During initialization, always update all bugs.
				if w == null: return true
				var diff: Vector2 = c.global_position - w.segments[0].global_position
				if abs(diff.x) > Globals.visibility_range.x: return false
				if abs(diff.y) > Globals.visibility_range.y: return false
				return true
			var s: MultiplayerSynchronizer = c.get_node("MultiplayerSynchronizer")
			s.call_deferred("add_visibility_filter",f)
		total_bugs += 1
	$WormSpawner.spawn_function = _spawn_worm
	$SlimeSpawner.spawn_function = _spawn_slime
	$SplatterSpawner.spawn_function = _spawn_splatter
	# Handle requests to put slime splatters on the screen from other (child) scenes.
	Globals.request_splatter.connect(_make_splatter)
	# If multiplayer mode, set up client or server instance (whichever is needed).
	if Globals.is_client:
		_make_client()
	elif Globals.is_server:
		_make_server()
	else:
		_make_local()

# Dynamically set up pause menu.
# This has to be done after server is set up, or there's some error messages
# when running in a multiplayer context (some elements within the menu system
# attempt to get a unique multiplayer id, and fail).
func make_pause_menu() -> void:
	var pause_menu: Control = load("res://menus/pause_menu.tscn").instantiate()
	$Overlay.add_child(pause_menu)
	pause_menu.quit.connect(restart)
	pause_menu.process_mode = Node.PROCESS_MODE_ALWAYS
	pause_menu.hide()


# Make this screen a server process, listening for incoming connections.
func _make_server () -> void:
	multiplayer.multiplayer_peer = null
	multiplayer.peer_disconnected.connect(_on_client_disconnected)
	var peer := WebSocketMultiplayerPeer.new()
	if Globals.localhost:
		peer.create_server(1156)
	else:
		var key := load("res://cert/privkey.key")
		var cert := load("res://cert/fullchain.crt")
		var tls_options := TLSOptions.server(key,cert)
		peer.create_server(1156,"*",tls_options)
	multiplayer.multiplayer_peer = peer
	# Don't trigger menus on server process.
	MenuHandler.pause.disconnect(pause_game)
	# Don't trigger slimes from screen clicking.
	$Overlay/ClickableArea.hide()
	# Display a message to indicate we're a server.
	var message: String = "Server started, listening on port 1156"
	print (message)
	$ServerScreen/ConnectionInfo.text = message
	$ServerScreen.show()
	# Show list of online players (list is synchronized with connected peers).
	$Overlay/Players.show()
	# Start displaying log messages from the server.
	$Overlay/LogTimer.timeout.connect(_next_log)
	$Overlay/LogTimer.start()

# Make this screen a client process, and connect to the specified server.
func _make_client () -> void:
	multiplayer.multiplayer_peer = null
	multiplayer.connected_to_server.connect(_on_connected_to_server)
	multiplayer.connection_failed.connect(_on_connection_failed)
	multiplayer.server_disconnected.connect(_on_server_disconnected)
	var peer := WebSocketMultiplayerPeer.new()
	if Globals.localhost:
		peer.create_client("ws://localhost:1156")
	else:
		peer.create_client("wss://slimetime.mikeasaurus.ca:1156")
	multiplayer.multiplayer_peer = peer
	# Hide the screen until setup is complete.
	# Need the sprites to be properly synced with server.  Before then, things
	# are glitching out a bit.
	hide()
	# The rest of the setup will be done in _on_connected_to_server, once the
	# connection is established.
# Make this screen a local game.
func _make_local() -> void:
	# Add a single worm, id 1 (local "server"), no label.
	var worm: Worm = $WormSpawner.spawn([1,""])
	# Show game over screen when player dies in local game.
	worm.hurt.connect(game_over)
	# Update score when bug eaten in local game.
	worm.ate_bug.connect(_on_worm_ate_bug)
	# Set up pause menu.
	make_pause_menu()
	# Show instructions.
	call_deferred("_show_instructions")
func _show_instructions () -> void:
	# Only show instructions the first time playing.
	if Globals.showed_instructions: return
	var i: Label = $Overlay/Instructions
	i.modulate = Color.TRANSPARENT
	i.show()
	var msgs: Array[String]
	if Globals.touchscreen_controls:
		msgs = [
			"Tap on screen to shoot slime",
			"Press on screen to move in that direction",
			"Double-tap screen to jump"
		]
	else:
		msgs = [
			"Use WASD or arrow keys to move",
			"Click on screen to shoot slime",
			"Press spacebar to jump"
		]
	for msg in msgs:
		var tween: Tween = get_tree().create_tween()
		i.text = msg
		tween.tween_interval(1.0)
		tween.tween_property(i, "modulate", Color.WHITE, 1.0)
		tween.tween_interval(1.0)
		tween.tween_property(i, "modulate", Color.TRANSPARENT, 1.0)
		await tween.finished
	Globals.showed_instructions = true

# Listen for some keys.
func _input(event: InputEvent) -> void:
	if is_in_menu: return  # Ignore key presses while user is navigating a menu.
	elif is_game_over == true and (event is InputEventKey or event is InputEventMouseButton) and event.pressed:
		restart()
	elif is_dead_multiplayer == true and (event is InputEventKey or event is InputEventMouseButton) and event.pressed:
		respawn()
		is_dead_multiplayer = false
		_is_dying_multiplayer = false
	elif event.is_action_pressed("toggle_fullscreen"):
		if DisplayServer.window_get_mode() == DisplayServer.WindowMode.WINDOW_MODE_WINDOWED:
			DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN)
		else:
			DisplayServer.window_set_mode(DisplayServer.WindowMode.WINDOW_MODE_WINDOWED)
	elif event.is_action_pressed("open_chat") and Globals.is_client:
		# Do on next frame, to ignore the "c" character that was just pressed
		# (so it isn't typed in the chat window).
		await get_tree().process_frame
		open_chat()
		
func _on_worm_ate_bug() -> void:
	bugs_eaten += 1
	score += 100
	$Overlay/Score.text = "Score:\n %d"%score
	if bugs_eaten == total_bugs:
		won_game()

# Get the player's own worm.
func my_worm() -> Worm:
	return $Worms.get_node("worm"+str(multiplayer.get_unique_id()))
# Get a peer's worm.
func peer_worm (id: int) -> Worm:
	if $Worms.has_node("worm"+str(id)):
		return $Worms.get_node("worm"+str(id))
	else:
		return null

# Trigger a game over screen.
func game_over () -> void:
	if is_game_over: return  # Game Over screen already initiated?
	my_worm().explode()
	var prompt: String
	if Globals.touchscreen_controls:
		prompt = "Tap screen to restart"
	else:
		prompt = "Press any key / click to restart"
	@warning_ignore("integer_division")
	$GameOverScreen/Label.text = "GAME OVER\nScore: %d\nBugs eaten: %d/%d (%d%%)\n\n%s"%[score,bugs_eaten,total_bugs,score/total_bugs,prompt]
	$GameOverScreen.visible = true
	# Fade in the "GAME OVER" text.
	var tween: Tween = get_tree().create_tween()
	tween.tween_interval(1.0)
	tween.tween_property($GameOverScreen/Label, "theme_override_colors/font_color", Color.WHITE, 1.0)
	# Delay before waiting for a key press to restart.
	# "await" idea copied from ProjectEruption.
	await get_tree().create_timer(2.0).timeout
	is_game_over = true
# Similar, but in multiplayer context.
var _is_dying_multiplayer: bool = false
func multiplayer_death () -> void:
	if _is_dying_multiplayer: return  # Overlay screen already initiated?
	_is_dying_multiplayer = true
	my_worm().explode()
	_death_message.rpc_id(1)
	if Globals.touchscreen_controls:
		$GameOverScreen/Label.text = "YOU DIED\n\nTap screen to respawn"
	else:
		$GameOverScreen/Label.text = "YOU DIED\n\nPress any key / click to respawn"
	$GameOverScreen.visible = true
	# Fade in the "GAME OVER" text.
	var tween: Tween = get_tree().create_tween()
	tween.tween_interval(1.0)
	tween.tween_property($GameOverScreen/Label, "theme_override_colors/font_color", Color.WHITE, 1.0)
	# Delay before waiting for a key press to restart.
	# "await" idea copied from ProjectEruption.
	await get_tree().create_timer(2.0).timeout
	is_dead_multiplayer = true
@rpc("any_peer","reliable")
func _death_message ():
	var id: int = multiplayer.get_remote_sender_id()
	var handle: String = players[id][0]
	_log("%s has died."%handle)
func respawn () -> void:
	my_worm().respawn()
	$GameOverScreen.visible = false

# When the player has eaten all the bugs, display a message before restarting.
@warning_ignore("integer_division")
func won_game () -> void:
	if is_game_over: return  # Game Over screen already initiated?
	my_worm().controllable = false
	var time: int = (Time.get_ticks_msec() - start_time) / 1000
	var hours: int = time / 3600
	time %= 3600
	var minutes: int = time / 60
	var seconds: int = time % 60
	var tstring: String = "%02d:%02d:%02d"%[hours,minutes,seconds]
	var prompt: String
	if Globals.touchscreen_controls:
		prompt = "Tap screen to restart"
	else:
		prompt = "Press any key / click to restart"
	$GameOverScreen/Label.text = "CONGRATULATIONS!\nAll bugs eaten!\nTotal time: %s\n\n%s"%[tstring,prompt]
	$GameOverScreen/ColorRect.color = Color.hex(0x00ff0080)
	$GameOverScreen.visible = true
	# Fade in the "GAME OVER" text.
	var tween: Tween = get_tree().create_tween()
	tween.tween_interval(1.0)
	tween.tween_property($GameOverScreen/Label, "theme_override_colors/font_color", Color.WHITE, 1.0)
	# Delay before waiting for a key press to restart.
	# "await" idea copied from ProjectEruption.
	await get_tree().create_timer(2.0).timeout
	is_game_over = true

# Restart the game after a game over screen.
func restart () -> void:
	get_tree().paused = false  # Unpause the game.
	Globals.reset()  # Reset global state
	MenuHandler.clear_menus()
	# Disconnect from server.
	multiplayer.multiplayer_peer.close()
	multiplayer.multiplayer_peer = OfflineMultiplayerPeer.new()
	# Go back to main menu.
	get_tree().change_scene_to_file("res://menus/main_menu.tscn")

# Bring up pause menu.
func pause_game () -> void:
	# Ignore the pause functionality if in a game over state.
	if is_game_over: return
	# For single player, pause the screen.
	# For multiplayer, need to keep everything running.
	if not Globals.is_client:
		get_tree().paused = true
	# Ignore keys while in a menu system (don't move the worm).
	is_in_menu = true
	my_worm().controllable = false
	MenuHandler.activate_menu($Overlay/PauseMenu)

func unpause_game () -> void:
	get_tree().paused = false
	is_in_menu = false
	my_worm().controllable = true

# Handle slime shooting.
func _on_clickable_area_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			var worm: Worm = my_worm()
			# In case not initialized yet (clicked screen *just* after starting).
			if worm == null: return
			# Query worm for where slime should be spawned.
			var position_and_velocity: Array[Vector2] = worm.segments[0].shoot_slime(get_global_mouse_position())
			var pos: Vector2 = position_and_velocity[0]
			var vel: Vector2 = position_and_velocity[1]
			# Spawn the slime.
			# Worm front could be z_index+5 if turned around.
			_shoot_slime.rpc_id(1, pos, vel, worm.segments[0].z_index+5)
@rpc("any_peer","call_local","reliable")
func _shoot_slime (pos: Vector2, vel: Vector2, z: int = 0):
	var slime = $SlimeSpawner.spawn()
	slime.global_position = pos
	slime.linear_velocity = vel
	slime.z_index = z
func _spawn_slime (_data):
	var slime := preload("res://features/slime.tscn").instantiate()
	# Only enable collision detection on server copy of slime.
	if Globals.is_client:
		slime.collision_mask = 0
	return slime
func _make_splatter (pos: Vector2, direction: Vector2, z: int = 0, sound: bool = true):
	# Make sure this is only done on authority.
	# The other clients will see it via SplatterSpawner.
	if multiplayer.get_unique_id() != 1: return
	var s: int
	if sound:
		s = 1
	else:
		s = 0
	$SplatterSpawner.spawn(PackedVector2Array([pos,direction,Vector2(z,s)]))
func _spawn_splatter (data: PackedVector2Array):
	var splatter: Splatter = preload("res://features/splatter.tscn").instantiate()
	var pos: Vector2 = data[0]
	var direction: Vector2 = data[1]
	var z: int = int(data[2].x)
	var s: int = int(data[2].y)
	splatter.global_position = pos
	splatter.direction = direction
	splatter.z_index = z
	if s == 1:
		splatter.sound = true
	else:
		splatter.sound = false
	return splatter

# Multiplayer functionality

# Keep track of all connected players (server only)
var players := {}
# Messages that appear on the top of the screen.
var logs := []
var next_log : int = 0

# Pass user information once connection is made.
func _on_connected_to_server () -> void:
	# Add pause menu.
	# Have to wait until server connection, or some elements of the pause menu
	# (maybe appearance editor?) complain about being unable to get unique id.
	make_pause_menu()
	# Hide the score, not used for multiplayer.
	$Overlay/Score.visible = false
	# Register the player on the server (store user handle and then spawn a worm).
	_register_player.rpc_id(1,Globals.handle)
	await get_tree().create_timer(0.1).timeout
	show()
# If server disconnects unexpectedly, return to main menu.
func _on_server_disconnected () -> void:
	# Note: this seems to get called on a client after a disconnect, so in that
	# case ignore this signal.
	if not Globals.is_client: return  # Already in the process of shutting down client and restarting.
	restart()
func _on_connection_failed() -> void:
	$Overlay/LogLabel.text = "Connection failed.  Playing locally."
func _on_client_disconnected (id) -> void:
	if id not in players: return  # Ignore test coonections (before player fully connected)
	_log("%s has left the server."%players[id][0])
	var worm: Worm = players[id][1]
	$Worms.remove_child(worm)
	worm.queue_free()
	players.erase(id)
	_update_player_list()
	_remove_beachball(id)
	
# Give new client all info needed to get started.
@rpc("any_peer","reliable")
func _register_player (handle) -> void:
	# Create a worm for the player to control.
	var id: int = multiplayer.get_remote_sender_id()
	var worm: Worm = $WormSpawner.spawn([id,handle])
	# Store player information.
	players[id] = [handle,worm]
	# Send a log message, telling everyone that a new player has arrived.
	_log("%s has joined the server."%handle)
	# Also update list of online players.
	_update_player_list()
# Custom spawner for worms, to set up the multiplayer authority properly.
func _spawn_worm (data):
	var id: int = data[0]
	var handle: String = data[1]
	var worm := preload("res://worm/worm.tscn").instantiate()
	# Set worm name to be consistent with peer id, so it can be synchronized.
	worm.name = "worm"+str(id)
	# Add a label to the worm.
	worm.get_node("WormFront/Sprites/NameLabel").text = handle
	# Set the multiplayer authority for this worm.
	# (the client that will control the worm movement).
	worm.set_multiplayer_authority(id)
	# If this is our worm, display it in front of any other worms in the same area.
	if id == multiplayer.get_unique_id():
		worm.z_index += 25  # 5 segments in a worm, each with up to 5 sub-layers?
	return worm
# Update list of online players.
func _update_player_list() -> void:
	var list: String = ""
	for id in players:
		var handle: String = players[id][0]
		list += "\n"+handle
	$Overlay/Players.text = "Online:"+list
# Send a system message to the clients.
func _log (msg: String) -> void:
	logs.append(msg)
	print (msg)
# Triggered by LogTimer
func _next_log () -> void:
	if next_log < len(logs):
		$Overlay/LogLabel.text = logs[next_log]
		$Overlay/LogLabel.modulate = Color.WHITE
		next_log += 1
	else:
		# If no new messages, fade out the last message shown.
		var tween: Tween = get_tree().create_tween()
		tween.tween_property($Overlay/LogLabel, "modulate", Color.TRANSPARENT, 1)

# Connect signals for our worm.
func _on_worm_spawner_spawned(worm: Worm) -> void:
	if worm.name == "worm"+str(multiplayer.get_unique_id()):
		worm.hurt.connect(multiplayer_death)

####################
# Chat integration
####################

# Highlight chat button when hovered.
func _on_chat_button_mouse_entered() -> void:
	$Overlay/Shortcuts/ChatButton.self_modulate = Color.WHITE
func _on_chat_button_mouse_exited() -> void:
	$Overlay/Shortcuts/ChatButton.self_modulate = Color.hex(0xffffff77)
# Open chat window with button pressed.
func open_chat() -> void:
	is_in_menu = true
	my_worm().controllable = false
	MenuHandler.activate_menu($Overlay/Chat)
func _on_chat_button_gui_input(event: InputEvent) -> void:
	# Ignore the chat functionality if in a game over state.
	if is_game_over: return
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			open_chat()
# Show a little indicator when the chat has more messages available to read.
func _on_chat_new_message_notifier() -> void:
	$Overlay/Shortcuts/ChatButton/Notifier.show()
func _on_chat_all_messages_read() -> void:
	$Overlay/Shortcuts/ChatButton/Notifier.hide()

# Beach ball spawning.
var balls: Dictionary = {}
func _on_beachball_button_mouse_entered() -> void:
	$Overlay/Shortcuts/BeachballButton.self_modulate = Color.WHITE
func _on_beachball_button_mouse_exited() -> void:
	$Overlay/Shortcuts/BeachballButton.self_modulate = Color.hex(0xffffff77)
func _on_beachball_button_gui_input(event: InputEvent) -> void:
	# Ignore the beach ball functionality if in a game over state.
	if is_game_over: return
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			# Spawn the ball near the player.
			var worm: Worm = my_worm()
			var ball_position = worm.segments[0].global_position \
				+ worm.segments[0].facing_direction * 100 \
				- worm.segments[0].feet_direction * 100
			_add_beachball.rpc_id(1,ball_position)
@rpc("any_peer","reliable")
func _add_beachball (pos) -> void:
	var id: int = multiplayer.get_remote_sender_id()
	# Only one ball spawned per player.
	if id in balls:
		_remove_beachball(id)
	var ball = load("res://features/beachball.tscn").instantiate()
	balls[id] = ball
	ball.global_position = pos
	$Beachballs.add_child(ball,true)
	# Don't show ball right away, or it briefly shows up at (0,0)?
	ball.hide()
	await get_tree().create_timer(0.1).timeout
	ball.show()
func _remove_beachball (id: int) -> void:
	if id in balls:
		$Beachballs.remove_child(balls[id])
		balls.erase(id)

# Reactions.
var _reactions_menu_opened: bool = false
func _on_reaction_button_mouse_entered() -> void:
	$Overlay/Shortcuts/ReactionButton.self_modulate = Color.WHITE
func _on_reaction_button_mouse_exited() -> void:
	if not _reactions_menu_opened:
		$Overlay/Shortcuts/ReactionButton.self_modulate = Color.hex(0xffffff77)
func _on_reaction_button_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			if _reactions_menu_opened:
				$Overlay/Shortcuts/ReactionButton.self_modulate = Color.hex(0xffffff77)
				$Overlay/Reactions.hide()
				_reactions_menu_opened = false
			else:
				$Overlay/Shortcuts/ReactionButton.self_modulate = Color.WHITE
				$Overlay/Reactions.show()
				_reactions_menu_opened = true

func _on_surprised_button_mouse_entered() -> void:
	$Overlay/Reactions/SurprisedButton.self_modulate = Color.WHITE
func _on_surprised_button_mouse_exited() -> void:
	$Overlay/Reactions/SurprisedButton.self_modulate = Color.hex(0xffffff77)
func _on_surprised_button_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_start_reaction("surprised")

func _on_confused_button_mouse_entered() -> void:
	$Overlay/Reactions/ConfusedButton.self_modulate = Color.WHITE
func _on_confused_button_mouse_exited() -> void:
	$Overlay/Reactions/ConfusedButton.self_modulate = Color.hex(0xffffff77)
func _on_confused_button_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_start_reaction("confused")

func _on_grumble_button_mouse_entered() -> void:
	$Overlay/Reactions/GrumbleButton.self_modulate = Color.WHITE
func _on_grumble_button_mouse_exited() -> void:
	$Overlay/Reactions/GrumbleButton.self_modulate = Color.hex(0xffffff77)
func _on_grumble_button_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_start_reaction("grumble")

func _on_slime_heart_button_mouse_entered() -> void:
	$Overlay/Reactions/SlimeHeartButton.self_modulate = Color.WHITE
func _on_slime_heart_button_mouse_exited() -> void:
	$Overlay/Reactions/SlimeHeartButton.self_modulate = Color.hex(0xffffff77)
func _on_slime_heart_button_gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_start_reaction("slimeheart")

func _start_reaction (reaction: String) -> void:
	var a: AnimatedSprite2D = my_worm().segments[0].get_node("Sprites/Reaction")
	a.play(reaction)
	a.show()
	$Overlay/Reactions/ReactionTimer.start()
func _on_reaction_timer_timeout() -> void:
	var a: AnimatedSprite2D = my_worm().segments[0].get_node("Sprites/Reaction")
	a.stop()
	a.hide()
