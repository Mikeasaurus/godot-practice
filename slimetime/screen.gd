extends Node2D

var is_game_over: bool = false
var is_dead_multiplayer: bool = false

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	# Connect the menu toggle key for pausing / unpausing the game.
	MenuHandler.pause.connect(pause_game)
	MenuHandler.done_submenus.connect(unpause_game)
	if Globals.touchscreen_controls:
		$Overlay/Shortcuts/PauseButton.show()
		$Overlay/Shrotcuts/PauseButton.pressed.connect(pause_game)
	# Connect worm damage signal directly to game over screen.
	$Worm.hurt.connect(game_over)
	# Use better names for the sprites generated from SpriteTileMapLayer.
	# The default names are autogenerated, and are causing problems with MultiplayerSyncrhonizer.
	# In particular, sometimes the auto-generated names don't match up to the right sprite between client and server?
	# First, need to force the TileMapLayer to instantiate its scenes, because normally this is deferred and we can't
	# see the sprites from this _ready() function.
	$SpriteTileMapLayer.update_internals()
	for c in $SpriteTileMapLayer.get_children():
		c.name = c.scene_file_path.split('/')[-1].split('.')[0]+"_"+str(c.position.x)+"_"+str(c.position.y)
	# If multiplayer mode, set up client or server instance (whichever is needed).
	$WormSpawner.spawn_function = _spawn_worm
	$SlimeSpawner.spawn_function = _spawn_slime
	if Globals.is_client:
		_make_client()
	elif Globals.is_server:
		_make_server()

# Make this screen a server process, listening for incoming connections.
func _make_server () -> void:
	multiplayer.multiplayer_peer = null
	multiplayer.peer_connected.connect(_on_client_connected)
	multiplayer.peer_disconnected.connect(_on_client_disconnected)
	var peer := WebSocketMultiplayerPeer.new()
	peer.create_server(1156)
	multiplayer.multiplayer_peer = peer
	# Don't trigger menus on server process.
	MenuHandler.pause.disconnect(pause_game)
	# Disable worm on server side (not needed, and don't want to process keyboard controls in here).
	$Worm.queue_free()
# Make this screen a client process, and connect to the specified server.
func _make_client () -> void:
	multiplayer.multiplayer_peer = null
	multiplayer.connected_to_server.connect(_on_connected_to_server)
	multiplayer.connection_failed.connect(_on_connection_failed)
	multiplayer.server_disconnected.connect(_on_server_disconnected)
	var peer := WebSocketMultiplayerPeer.new()
	peer.create_client("ws://"+Globals.check_invite(Globals.invite)+":1156")
	multiplayer.multiplayer_peer = peer
	$Overlay/LogLabel.text = "Attempting to connect..."
	# The rest of the setup will be done in _on_connected_to_server, once the
	# connection is established.

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	pass

# Listen for some keys.
func _input(event: InputEvent) -> void:
	if Globals.debug_keys and event.is_action_pressed("instakill"):
		game_over()
	elif is_game_over == true and (event is InputEventKey or event is InputEventMouseButton) and event.pressed:
		restart()
	elif is_dead_multiplayer == true and (event is InputEventKey or event is InputEventMouseButton) and event.pressed:
		respawn()
		is_dead_multiplayer = false
		_is_dying_multiplayer = false
		
func _on_worm_ate_bug() -> void:
	Globals.score += 100
	$Overlay/Score.text = "Score:\n %d"%Globals.score

# Trigger a game over screen.
func game_over () -> void:
	if is_game_over: return  # Game Over screen already initiated?
	$Worm.explode()
	if Globals.touchscreen_controls:
		$GameOverScreen/Label.text = "GAME OVER\nScore: %d\n\nTap screen to restart"%Globals.score
	else:
		$GameOverScreen/Label.text = "GAME OVER\nScore: %d\n\nPress any key / click to restart"%Globals.score
	$GameOverScreen.visible = true
	# Fade in the "GAME OVER" text.
	var tween: Tween = get_tree().create_tween()
	tween.tween_interval(1.0)
	tween.tween_property($GameOverScreen/Label, "theme_override_colors/font_color", Color.WHITE, 1.0)
	# Delay before waiting for a key press to restart.
	# "await" idea copied from ProjectEruption.
	await get_tree().create_timer(2.0).timeout
	is_game_over = true
# Similar, but in multiplayer context.
var _is_dying_multiplayer: bool = false
func multiplayer_death () -> void:
	if _is_dying_multiplayer: return  # Overlay screen already initiated?
	_is_dying_multiplayer = true
	var worm: Worm = $Worms.get_node("worm"+str(multiplayer.get_unique_id()))
	worm.explode()
	_death_message.rpc_id(1)
	if Globals.touchscreen_controls:
		$GameOverScreen/Label.text = "YOU DIED\n\nTap screen to respawn"
	else:
		$GameOverScreen/Label.text = "YOU DIED\n\nPress any key / click to respawn"
	$GameOverScreen.visible = true
	# Fade in the "GAME OVER" text.
	var tween: Tween = get_tree().create_tween()
	tween.tween_interval(1.0)
	tween.tween_property($GameOverScreen/Label, "theme_override_colors/font_color", Color.WHITE, 1.0)
	# Delay before waiting for a key press to restart.
	# "await" idea copied from ProjectEruption.
	await get_tree().create_timer(2.0).timeout
	is_dead_multiplayer = true
@rpc("any_peer","reliable")
func _death_message ():
	var id: int = multiplayer.get_remote_sender_id()
	var handle: String = players[id][0]
	_log.rpc("%s has died."%handle)
func respawn () -> void:
	var worm: Worm = $Worms.get_node("worm"+str(multiplayer.get_unique_id()))
	worm.respawn()
	$GameOverScreen.visible = false

# Restart the game after a game over screen.
func restart () -> void:
	get_tree().paused = false  # Unpause the game.
	Globals.reset()  # Reset global state (score, etc.)
	MenuHandler.clear_menus()
	# Disconnect from server.
	multiplayer.multiplayer_peer.close()
	# Go back to main menu.
	get_tree().change_scene_to_file("res://menus/main_menu.tscn")

# Bring up pause menu.
func pause_game () -> void:
	# Ignore the pause functionality if in a game over state.
	if is_game_over: return
	get_tree().paused = true
	MenuHandler.activate_menu($Overlay/PauseMenu)

func unpause_game () -> void:
	get_tree().paused = false

# Handle slime shooting.
func shoot_slime (pos: Vector2, vel: Vector2):
	# Invoke on server.
	_shoot_slime.rpc_id(1, pos, vel)
@rpc("any_peer","call_local","reliable")
func _shoot_slime (pos: Vector2, vel: Vector2):
	var slime = $SlimeSpawner.spawn()
	slime.global_position = pos
	slime.linear_velocity = vel
func _spawn_slime (_data):
	var slime := preload("res://features/slime.tscn").instantiate()
	# Only enable collision detection on server copy of slime.
	if Globals.is_client:
		slime.collision_mask = 0
	return slime

# Multiplayer functionality

# Keep track of all connected players (server only)
var players := {}
# Messages that appear on the top of the screen.
var logs := []
var next_log : int = 0
# Chat history
var chat := []

# Pass user information once connection is made.
func _on_connected_to_server () -> void:
	# Start displaying log messages from the server, rate limited.
	$Overlay/LogTimer.timeout.connect(_next_log)
	# Remove the local worm on client side, and instead spawn one in the "Worms" node.
	# The "Worms" path is managed by MultiplayerSpawner so it should automatically get spawned on all
	# peers as well.
	$Worm.queue_free()
	# Hide the score, not used for multiplayer.
	$Overlay/Score.visible = false
	# Register the player on the server (store user handle and then spawn a worm).
	_register_player.rpc_id(1,Globals.handle)
	# Start the log message display, after a short delay (above) to wait for our own connection message.
	_next_log()
	$Overlay/LogTimer.start()
# If server disconnects unexpectedly, return to main menu.
func _on_server_disconnected () -> void:
	# Note: this seems to get called on a client after a disconnect, so in that
	# case ignore this signal.
	if not Globals.is_client: return  # Already in the process of shutting down client and restarting.
	restart()
func _on_client_connected (id) -> void:
	# When a client connects, synchronize their state.
	_load_chat.rpc_id(id,chat)
func _on_connection_failed() -> void:
	$Overlay/LogLabel.text = "Connection failed.  Playing locally."
func _on_client_disconnected (id) -> void:
	if id not in players: return  # Ignore test coonections (before player fully connected)
	_log.rpc("%s has left the server."%players[id][0])
	var worm: Worm = players[id][1]
	$Worms.remove_child(worm)
	worm.queue_free()
	players.erase(id)
# Give new client all info needed to get started.
@rpc("reliable")
func _load_chat (chat_history):
	chat = chat_history
@rpc("any_peer","reliable")
func _register_player (handle) -> void:
	# Create a worm for the player to control.
	var id: int = multiplayer.get_remote_sender_id()
	var worm: Worm = $WormSpawner.spawn([id,handle])
	# Store player information.
	players[id] = [handle,worm]
	# Send a log message, telling everyone that a new player has arrived.
	_log.rpc("%s has joined the server."%handle)
# Custom spawner for worms, to set up the multiplayer authority properly.
func _spawn_worm (data):
	var id: int = data[0]
	var handle: String = data[1]
	var worm := preload("res://worm/worm.tscn").instantiate()
	# Set worm name to be consistent with peer id, so it can be synchronized.
	worm.name = "worm"+str(id)
	# Add a label to the worm.
	worm.get_node("WormFront/Sprites/NameLabel").text = handle
	# Set the multiplayer authority for this worm.
	# (the client that will control the worm movement).
	worm.set_multiplayer_authority(id)
	return worm
# Send a system message to the clients.
@rpc("call_local","reliable")
func _log (msg: String) -> void:
	logs.append(msg)
	if multiplayer.is_server():
		print (msg)
# Triggered by LogTimer
func _next_log () -> void:
	if next_log < len(logs):
		$Overlay/LogLabel.text = logs[next_log]
		$Overlay/LogLabel.add_theme_color_override("font_color",Color(0,1,0,1))
		$Overlay/LogLabel.add_theme_color_override("font_outline_color",Color(0,0,0,1))
		next_log += 1
	else:
		# If no new messages, fade out the last message shown.
		var tween: Tween = get_tree().create_tween()
		tween.tween_property($Overlay/LogLabel, "theme_override_colors/font_color", Color(0,1,0,0), 1)
		tween.parallel().tween_property($Overlay/LogLabel, "theme_override_colors/font_outline_color", Color(0,0,0,0), 1)
# Send a message to the chat.
@rpc("any_peer","call_local","reliable")
func _send_chat (msg: String) -> void:
	var sender := multiplayer.get_remote_sender_id()
	# Encode bubble position, sender info.
	chat.append([players[sender][0],msg])

# Connect signals for our worm.
func _on_worm_spawner_spawned(worm: Worm) -> void:
	if worm.name == "worm"+str(multiplayer.get_unique_id()):
		worm.slime_shot.connect(shoot_slime)
		worm.hurt.connect(multiplayer_death)

# Highlight chat button when hovered.
func _on_chat_button_mouse_entered() -> void:
	$Overlay/Shortcuts/ChatButton.self_modulate = Color.WHITE
func _on_chat_button_mouse_exited() -> void:
	$Overlay/Shortcuts/ChatButton.self_modulate = Color.hex(0xffffff77)
# Open chat window with button pressed.
func _on_chat_button_gui_input(event: InputEvent) -> void:
	# Ignore the chat functionality if in a game over state.
	if is_game_over: return
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			get_tree().paused = true
			MenuHandler.activate_menu($Overlay/Chat)
